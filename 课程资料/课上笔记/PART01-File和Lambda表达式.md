# 一、File

## File类概述

- File类的每一个实例可以表示硬盘(文件系统)中的一个文件或目录(实际上表示的是一个抽象路径)

- 使用File可以做到:
  1. 访问其表示的文件或目录的属性信息,例如:名字,大小,修改时间等等
  2. 创建和删除文件或目录
  3. 访问一个目录中的子项

## 获取文件及其属性

```
length(): 返回文件的长度, 单位是字节数(如果File是目录, 则返回0)
exists(): 判断当前文件或目录是否存在，存在则返回true
isFile(): 判断当前file是否为文件，是文件则返回true
isDirectory(): 判断当前file是否为目录，是目录返回true
getName(): 获取当前File文件或目录的名字
getParent(): 获取当前File父目录的路径
getAbsolutePath(): 获取当前File文件或目录的完整路径
```

### 代码案例

```java

```

## 创建文件

```
createNewFile(): 创建指定路径和名称的文件, 如果文件不存在, 则创建并返回true, 否则就不创建并返回false
```

### 	代码案例

```java

```

## 删除文件

```
delete(): 删除文件或删除空目录, 删除成功返回true(非空目录删除会失败)
```

###  代码案例

```java

```

## 创建目录

```
mkdir(): 创建指定路径和名称的目录, 如果目录不存在, 则创建并返回true, 否则就不创建并返回false
mkdirs(): 创建指定路径和名称的多级目录, 如果目录不存在, 则创建并返回true, 否则就不创建并返回false
```

###  代码案例

```java

```

## 删除目录

```
delete(): 删除文件或删除空目录, 删除成功返回true(非空目录删除会失败)
```

###  代码案例

```java

```

## 获取目录中的子项

### 代码案例

```java

```

## 递归遍历目录

递归（recursion）是一种常见的解决问题的方法，即把问题逐渐简单化。

递归的基本思想就是“自己调用自己”，一个使用递归技术的方法将会直接或者间接的调用自己。

```java
 m();
 ...
 public void m(){
   ...
   m();
   ...
 }
```

需要注意的是: 递归方法一定要有出口, 否则将会一直自己调用自己, 变成死循环, 严重时将会导致内存溢出!

### 需求: 遍历指定File(目录)下的所有子目录和子文件, 输出该目录下的所有目录和文件名

```
思路: 声明一个diGui目录的方法, 接收一个File类型的对象, 方法内部实现如下: 
1.判断当前File是否为文件(防止第一次传入的是文件)
  1.1.如果file是文件, 输出: "文件不支持递归!"
  1.2.如果file是目录, 则继续执行第2步
2.获取当前目录下的所有子目录及子文件对象组成的File数组
3.遍历当前目录下的所有子目录及子文件对象
4.判断当前遍历的是目录还是文件
  4.1.如果当前遍历的是文件, 输出该文件的路径+名称
  4.2.如果当前遍历的是目录, 输出当前目录的路径+名称
  并以此目录作为根, 接着遍历该目录下的所有子目录和子文件, 输出该目录下的所有目录和文件名
```

### 统计一个目录下所有文件的大小之和

#### 代码案例

```java

```

### 获取一个目录中符合过滤条件的所有子项

#### 代码案例

```java

```

#  二、Lambda表达式

- JDK8之后,java支持了lambda表达式这个特性.

- lambda可以用更精简的代码创建匿名内部类.但是该匿名内部类实现的接口只能有一个抽象方法,否则无法使用!

- lambda表达式是编译器认可的,最终会将其改为内部类编译到class文件中

## 代码案例

```java

```

